# 객체

> 출처 [모던 JavaScript 튜토리얼](https://ko.javascript.info/)을 보고 정리한 내용입니다.

하나의 데이터(문자열,숫자 등)만 담을 수 있는 원시형과는 다르게 객체형은 다양한 데이터를 담을 수 있다.

객체는 중괄호 안에 key, value의 쌍으로 생성한다.

```
let user = {     // 객체
  name: "John",  // 키: "name",  값: "John"
  age: 30        // 키: "age", 값: 30
};
```

위 객체에서 name 프로퍼티를 삭제한다면 delete 연산자를 이용한다.

```
delete user.age;
```

**계산된 프로퍼티**

-   객체를 만들 때 객체 리터럴 안의 키가 대괄호로 둘러싸여 있는 경우 계싼된 프로퍼티라고 부른다.

```
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");

let bag = {
  [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아온 후에 객체가 정의된다.
};
```

**in 연산자**

-   객체에 프로퍼티가 존재하는지 확인할 땐 'in'연산자를 사용한다.

```
let user = { age: 30 };

let key = "age";
```

-   자바스크립트는 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환하는데 이런 특성을 이용해 아래처럼 프로퍼티의 존재여부를 확인할 수 있다.

```
let user = { age: 30 };

if(user.name===undefined)
    console.log("name is not in user");
```

-   그러면 in연산자의 필요성에 의구심이 생기는데 다음과 같이 객체의 2번째 프로퍼티가 undefined일 때 유용한다.

```
let user = {age:30, name:undefined};
console.log(user.name) // undefined
```

-   이렇게 호출에 의해서는 객체가 존재하지 않아서 undefined인지, 객체의 2번째 프로퍼티가 undefined인지 구별할 수 없기 때문이다.

# 참조에 의한 객체 복사

객체와 원시 타입의 근본적인 차이는 원시 타입은 값 그대로 변수에 저장되는 반면 객체는 객체가 저장되어 있는 '메모리 주소'인 객체에 대한 '참조 값'이 저장된다.

아래 예시에서 객체의 특성이 보여진다. user변수를 복사한 admin은 객체의 참조 값이 저장되어 admin에서 name 프로퍼티를 수정하면 user에서도 수정된다. 둘은 하나의 참조값을 가진 같은 객체를 가르키고 있다.

```
let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // 'admin' 참조 값에 의해 변경됨

alert(user.name);
```

다음은 객체와 함수의 특성을 보여주는데 변수에 객체를 저장하면 이는 어떠한 값이 저장되는 것이 아닌 주소가 저장된다.

그리고 함수는 인자로 받은 값을 그대로 사용하는 것이 아니라 복사해서 사용한다.

아래 코드에서 변수 a에는 원시값이 , b에는 객체가 저장되었는데 이를 함수에 인자로 전달하면 함수 changeA에서는 a값을 복사해 더해주었기 때문에 전역변수 a에는 영향이 가지 않는다.

반면 changeB함수에서는 마찬가지로 인자로 전달된 객체를 복사하는데 이때 인자는 정확히 말하면 객체의 주소가 전달되었기 때문에 함수에서 객체를 건드리면 외부에서도 바뀐 값이 적용된다.

```
let a = 0;
let b = {
  number: 0
};

function changeA(a){
  a++;
}

function changeB(b){
  b.number++;
}

changeA(a);
changeB(b);

console.log(a); // 0
console.log(b.number); // 1
```

-   따라서 기존 객체와 같으면서 독립적인 객체를 만들려면 아래와 같은 방식을 이용해야 한다. 자바스크립트는 객체 복제 내장 메서드를 지원하지 않는다.

```
let user = {
  name: "John",
  age: 30
};

let clone = {}; // 새로운 빈 객체

// 빈 객체에 user 프로퍼티 전부를 복사해 넣습니다.
for (let key in user) {
  clone[key] = user[key];
}

// 이제 clone은 완전히 독립적인 복제본이 되었습니다.
clone.name = "Pete"; // clone의 데이터를 변경합니다.

alert( user.name ); // 기존 객체에는 여전히 John이 있습니다.
```

혹은 Object.assign을 사용해야 한다.

```
let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// permissions1과 permissions2의 프로퍼티를 user로 복사합니다.
Object.assign(user, permissions1, permissions2);

// now user = { name: "John", canView: true, canEdit: true }
```

이 방식은 '얕은 복사'로 중첩된 객체의 경우는 처리하지 못한다.

다음은 Object.assgin이 얕은 복사를 하는 예시이다.

```
let b3 = {
  number1 : 0,
  deep_b3:{
    number2:0
  }
}

let clone_b3 = Object.assign({},b3);

b3.number1++;
b3.deep_b3.number2++;

console.log(clone_b3.number1); // 0
console.log(clone_b3.deep_b3.number2); // 1
```
